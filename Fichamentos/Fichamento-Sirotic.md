# Comparison of Java Virtual and Non-Virtual Threads in Parallel Programming
Sirotić, Zlatko; Sovilj, Siniša; Oršulić, Matija; Pripužić, Krešimir. “Comparison of Java Virtual and Non-Virtual Threads in Parallel Programming” in 48th MIPRO ICT and Electronics Convention (MIPRO), Software and Systems Engineering Track (SSE), 2025. doi: [10.1109/SACI60582.2024.10619722](https://doi.org/10.1109/SACI60582.2024.10619722)

## 1. Fichamento de Conteúdo

O artigo analisa a eficiência das *virtual threads* Java, introduzidas na versão de suporte de longo prazo 21 (LTS) em setembro de 2023, especificamente no contexto da programação paralela. O contexto da introdução das *virtual threads* é a superação das desvantagens das *platform threads* (ou não virtuais), que são limitadas devido ao mapeamento um-para-um com as threads do sistema operacional e sofrem com a sobrecarga da troca de contexto. Embora as *virtual threads* sejam principalmente destinadas a aplicações concorrentes de alto rendimento, oferecendo escala para tarefas de espera intensiva, o problema investigado é se elas são significativamente mais lentas em programas puramente paralelos. O método empregado envolve a criação de quatro programas paralelos para a contagem de números primos, comparando três soluções de threads não virtuais (Executors Java 5, ForkJoin Java 7 e Streams Java 8) com uma solução de *virtual threads* (Executors Java 21). A avaliação da velocidade foi realizada em dois processadores Intel i7 de diferentes gerações. Os resultados indicam que, no caso de uso analisado, as *virtual threads* foram apenas marginalmente mais lentas do que as soluções baseadas em threads não virtuais. O estudo conclui que, mesmo não sendo o foco principal, as *virtual threads* demonstraram desempenho comparável para programação paralela, mantendo os benefícios de código mais legível e fácil de depurar em comparação com a programação assíncrona.

## 2. Fichamento Bibliográfico

*   _Virtual Threads Mapping_: o tempo de execução Java (JDK) usa um agendador para atribuir uma *virtual thread* a uma *platform thread* (que atua como portadora ou *carrier*) por meio de um processo chamado montagem (*mounting*). Quando uma *virtual thread* chama uma operação de I/O de bloqueio, ela é suspensa e "desmontada" de sua *platform thread*, liberando a *platform thread* para executar outras *virtual threads*.
*  _Virtual Threads Scalling_: o objetivo principal das *virtual threads* é fornecer escala (*scale* ou *higher throughput*) para aplicações concorrentes que possuem muitas tarefas que esperam a maior parte do tempo. Elas não são projetadas para serem mais rápidas, mas sim para serem criadas de forma "barata".
*   _Desvantagens das Platform Threads e da Programação Assíncrona:_ threads baseadas no SO (não virtuais) têm desvantagens como o tempo de sobrecarga devido à troca de contexto (*context switching*) e a limitação do número de threads gerenciáveis. A programação assíncrona, embora aborde essas limitações, introduz seus próprios problemas, como programas que são difíceis de escrever, ler, testar, depurar e perfilar.
*   _Java Paralleling Methods:_ para a análise comparativa de velocidade, o estudo utilizou implementações de paralelismo disponíveis em diferentes versões do Java: *Executors* (Java 5/6), *Fork Join framework* (Java 7) e *Parallel Streams* (Java 8). O programa de *virtual threads* foi implementado utilizando *Executors*.

#### 3. Fichamento de Citações

*   *"While Java non-virtual (or platform) threads are mapped one-to-one to operating system threads, multiple Java virtual threads can be executed on a single platform thread, i.e. on a single operating system thread, which makes the number of Java virtual threads practically unlimited."*
*   *"Java virtual threads enable writing code that is as efficient as asynchronous code but is more readable, much easier to debug, and provides clearer error messaging (exceptions) compared to asynchronous code."*
*   *"Virtual threads are cheap to create, to a point where you can have as many as you need."*
*   *"Use virtual threads in high-throughput concurrent applications, especially those that consist of a large number of concurrent tasks that spend much of their time waiting... Virtual threads are not faster threads; they do not run code any faster than platform threads. They exist to provide scale (higher throughput), not speed (lower latency)."*
*  **"It was found that Java 21 virtual threads were slightly slower in our case than the solution using non-virtual threads."*
*   *"...the solution with non-virtual threads is not significantly faster than the solution with virtual threads: 1.54 vs. 1.56 seconds (i7-7700HQ, 8 Java threads), or 0.22 vs. 0.23 seconds (i7-13700H, 20 Java threads)."*