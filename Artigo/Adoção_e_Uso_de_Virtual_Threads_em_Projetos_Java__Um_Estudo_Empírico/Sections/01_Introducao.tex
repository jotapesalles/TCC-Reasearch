\section{Introdução}
\label{sec:introducao}
O desenvolvimento de software moderno é crescentemente marcado por aplicações distribuídas, principalmente por arquiteturas de microsserviços hospedadas em ambientes de computação em nuvem, nas quais a gestão eficiente de CPU e memória é crítica para desempenho e custo operacional \cite{mohamed:21}. Historicamente, Java aborda concorrência com \textit{platform threads} (threads de plataforma), que encapsulam threads do sistema operacional e, embora familiares, tendem a ser “pesadas” quando mantidas em grande número, especialmente em cargas intensivas de entrada/saída (E/S) \cite{navarro:23, lasic:24}. Modelos assíncronos e reativos difundiram-se nos sistemas para resolver tais limitações por meio de E/S não bloqueante, ao custo de maior complexidade de desenvolvimento e manutenção \cite{navarro:23}. Nesse contexto, o JDK introduziu \textit{virtual threads} (threads virtuais, VT) em \textit{preview} e as estabilizou no JDK~21, conciliando programação síncrona com alta concorrência e baixo custo por tarefa \cite{jep444}.

Apesar desse avanço, \textbf{não há um panorama empírico consolidado sobre a adoção contemporânea de \textit{virtual threads} em projetos Java: onde aparecem, com que prevalência em relação a \textit{threads} de plataforma e quais padrões concretos de uso predominam em diferentes \textit{frameworks} e domínios}. Embora as VTs estejam estáveis no JDK~21 e sua viabilidade técnica tenha sido demonstrada, ainda faltam evidências sistemáticas sobre a influência de fatores como estilo de comunicação entre processos/serviços (IPC, do inglês \textit{Inter-Process Communication}), versões do JDK e bibliotecas de E/S na decisão de adoção, bem como sobre a interação com configurações padrão de \textit{frameworks} e estilos arquiteturais \cite{mohamed:21,navarro:23}.

A relevância do problema decorre das seguintes questões: as \textit{virtual threads} foram concebidas para promover melhoria de desempenho, eficiência e racionalização de recursos em software, otimizando o uso de CPU e memória em aplicações intensivas em \textit{I/O} e aumentando a taxa de transferência (\textit{throughput}) \cite{navarro:23}. Trata-se de uma capacidade estabilizada no JDK~21 \cite{jep444}, sobre a qual ainda há escassez de estudos em cenários realistas, especialmente em aplicações orientadas a banco de dados na nuvem \cite{lasic:24}. Em paralelo, há sinais de adoção em \textit{frameworks} e servidores web populares, como Quarkus, Spring e Jetty \cite{rosa:23}. Nesse contexto, compreender benefícios, custos e desafios de integração torna-se essencial para embasar decisões técnicas, mitigar riscos e orientar a construção de sistemas escaláveis e eficientes. Além disso, a estabilização das VTs no JDK~21 cria um período oportuno para observar tendências reais de adoção e consolidar recomendações que orientem decisões de engenharia com foco em automação, eficiência e uso de recursos \cite{jep444}.

\textbf{O objetivo geral deste trabalho é investigar a adoção contemporânea de \textit{virtual threads} em projetos Java, categorizando sua prevalência, padrões de uso e fatores associados, em contraste com o emprego de \textit{threads} de plataforma}. Especificamente, pretende-se: (i) minerar repositórios de código abertos para identificar indícios de adoção (por exemplo, ocorrências de \texttt{Thread.ofVirtual()} e executores de VT, além de opções de \textit{frameworks} que habilitam VT); (ii) classificar padrões de uso observados (como \textit{thread-per-request}, mapeamentos VTs ou PTs e arranjos híbridos com \textit{pools}); (iii) analisar fatores associados à adoção, incluindo \textit{framework}, versão do JDK, estilo de comunicação entre serviços (APIs \textit{REST} e corretores de mensagens) e bibliotecas de acesso a dados; (iv) examinar a evolução temporal pós-JDK~21 por período, domínio e ecossistema; e (v) identificar barreiras, \textit{smells} e antipadrões documentados em \textit{issues}/\textit{pull requests}, consolidando evidências em uma classificação de adoção.

Como resultados esperados, tem-se: (a) um panorama verificável da prevalência de VTs versus \textit{threads} de plataforma em projetos Java atuais; (b) uma classificação de padrões de uso de VTs com exemplos de código e contexto arquitetural; (c) um conjunto de fatores correlacionados à adoção (ou não adoção) combinando \textit{frameworks}, versões do JDK e bibliotecas de E/S para orientar decisões de engenharia; e (d) um catálogo de barreiras e antipadrões com sugestões de mitigação. Tais artefatos buscam apoiar a automação (simplificação do código concorrente), a eficiência e a racionalização de recursos no desenvolvimento e na operação de software.

Por fim, este trabalho está organizado da seguinte forma: a Seção~2 apresenta o referencial teórico e os trabalhos relacionados sobre VTs em aplicações Java (incluindo conceitos, relatos de adoção e usos característicos); a Seção~3 descreve o desenho do estudo empírico (estratégia de mineração, critérios de inclusão/exclusão, extração de evidências e métricas); a Seção~4 relata os resultados de adoção, padrões e fatores observados; a Seção~5 discute implicações práticas, ameaças à validade e recomendações de engenharia; e a Seção~6 conclui o trabalho e sugere direções futuras.