\section{Trabalhos Relacionados}
\label{sec:trabalhos_relacionados}

O surgimento das \textit{virtual threads} (VTs) introduziu uma nova abordagem para a concorrência em Java, visando conciliar a simplicidade da programação síncrona com alta escalabilidade e eficiência de recursos, especialmente em cenários intensivos em entrada/saída (E/S). A estabilização dessa capacidade no JDK 21  motiva a investigação de sua adoção contemporânea em projetos \textit{open-source}. Os trabalhos apresentados nesta seção estabelecem a viabilidade técnica e os benefícios de desempenho das VTs em cenários intensivos em E/S, como o acesso a dados e a renderização de \textit{templates} \textit{web}. Estudos demonstram que VTs superam consistentemente as \textit{platform threads} (PTs) tradicionais em eficiência de tempo de execução em tarefas de concorrência e análise de grafos, mas são ligeiramente mais lentas em programação puramente paralela (\textit{CPU-bound}).

La{\v{s}}i{\'c} et al. (2024)\nocite{lasic:24} conduziram um estudo com o objetivo de avaliar a eficiência das \textit{virtual threads} em aplicações de servidor orientadas a banco de dados. O método empregado envolveu a comparação da eficiência das VTs com as PTs tradicionais de Java em aplicações de servidor que utilizam o modelo \textit{thread-per-request} e acessam bancos de dados relacionais (\textit{MySQL, PostgreSQL e Oracle}) e não-relacionais (\textit{MongoDB, Neo4j, Cassandra}). Os resultados preliminares demonstraram que as VTs consistentemente apresentaram desempenho superior ao das \textit{threads} tradicionais, especialmente em operações CRUD de alto \textit{throughput}. Em aplicações com bancos de dados relacionais, a latência foi reduzida em média em aproximadamente $100$ microssegundos. Os autores propõem a utilização de VTs em aplicações de servidor modernas baseadas em \textit{frameworks} e orientadas a banco de dados em nuvem. O estudo  fornece a evidência técnica de que o uso de VTs traz benefícios claros de desempenho em cenários de E/S intensivos, como o acesso a dados, o que é relevante para o objetivo de investigar a adoção empírica das VTs em relação às bibliotecas de acesso a dados.

Outro trabalho realiza uma análise da eficiência das \textit{virtual threads} em cenários de programação paralela (\textit{CPU-bound}). Sirotic et al. (2025) \nocite{sirotic:25} comparou a velocidade de execução de quatro programas paralelos em Java (\textit{Executors, ForkJoin, Streams e Virtual Executors}) para a tarefa de contagem de números primos. O principal resultado encontrado é que as VTs se mostraram ligeiramente mais lentas do que a solução que utilizava \textit{threads} não virtuais para o problema. Por exemplo, a solução com PTs foi marginalmente mais rápida ($1,54$ s \textit{vs.} $1,56$ s) em um processador mais antigo, e ($0,22$ s \textit{vs.} $0,23$ s) em um processador mais novo. Este dado é crucial para o presente estudo, pois o uso de VTs para tarefas puramente \textit{CPU-bound} é considerado um antipadrão, o que, se observado em projetos reais, ajuda a catalogar barreiras e antipadrões. 

Investigando o ambiente de \textit{frameworks} reativos, Navarro et al. (2023)\nocite{navarro:23} analisaram considerações para a integração de \textit{virtual threads} em um \textit{framework} Java reativo (Quarkus), com foco em ambientes com recursos limitados. Os resultados revelaram que a integração inicial de VTs não apresentou desempenho tão bom quanto a abordagem reativa do \textit{framework}. Esta limitação foi atribuída a uma incompatibilidade fundamental entre as VTs e o \textit{framework} Netty, especialmente devido à alta pressão sobre o \textit{Garbage Collector} (GC) causada pelo uso de \textit{ThreadLocals}. O estudo de Navarro \textit{et al.} detalha as complexidades e barreiras técnicas que podem influenciar a adoção de VTs em arquiteturas.

Complementarmente, um estudo explorou como as VTs facilitam o \textit{Progressive Server-Side Rendering} (PSSR) utilizando \textit{template engines} \textit{web} tradicionais que dependem de interfaces bloqueantes. Os autores Pereira et al. (2025)\nocite{pereira:25} concluíram que as VTs permitem que \textit{engines} bloqueantes atinjam escalabilidade comparável àquelas projetadas para E/S não bloqueante, mantendo alto \textit{throughput} e simplificando a implementação de PSSR com estilos de código síncrono familiar. Em implementações Quarkus, a abordagem de VTs alcançou \textit{throughput} elevado ($4856$ requisições por segundo) e escalou efetivamente até $128$ usuários concorrentes. Este trabalho valida que VTs são uma solução eficaz para o padrão de uso \textit{thread-per-request} em aplicações \textit{web} \textit{I/O-bound}, um dos padrões que serão investigados.

Chirila e Sora (2024)\nocite{chirila:24} investigaram a avaliação de desempenho em tempo de execução de \textit{single thread} (ST), PT e VT no contexto da detecção de classes-chave. O objetivo era medir o desempenho da paralelização dos algoritmos \textit{HITS} e \textit{PageRank}, cruciais para a análise de grafos em engenharia de \textit{software}. O método consistiu em executar implementações dos algoritmos usando os três modelos de \textit{threading} (ST, PT e VT) em um conjunto de 14 projetos Java de tamanhos variados. Os algoritmos \textit{HITS} e \textit{PageRank} foram aplicados na representação em grafos dos sistemas analisados, ranqueando as classes por sua importância. O estudo revelou que o modelo VT superou consistentemente os modelos ST e PT, resultando em uma diminuição de tempo de execução de 58,41\% em comparação com o modelo ST no conjunto total de projetos. Eles também observaram que o modelo ST é melhor do que o PT em 12 dos 14 projetos, e o PT só superou o ST em projetos com mais de 1.700 nós, que consomem 90\% do tempo de execução total do conjunto. Este trabalho estabelece um contexto de desempenho geral, demonstrando a maior eficiência das VTs sobre as PTs, fornecendo um forte argumento para a adoção.

Por fim, um trabalho empírico que servirá de base metodológica para a mineração de código proposta é o de Zimmerle et al. (2022)\nocite{zimmerle:22}, que se concentrou na mineração do uso de APIs de \textit{Reactive Programming} (RP) em projetos \textit{open-source}. O objetivo era entender a prevalência do uso dos operadores em três bibliotecas \textit{Reactive Extensions} (Rx) (RxJava, RxJS e RxSwift). O método empregado envolveu a mineração de repositórios no GitHub que possuíam pelo menos $10$ estrelas, utilizado como um filtro de popularidade. Os autores baixaram os projetos e utilizaram expressões regulares (\textit{regex}) para buscar a ocorrência de invocações de operadores. O estudo demonstrou que $95,2\%$ dos operadores Rx estavam em uso, validando a mineração de repositórios como uma abordagem eficaz para quantificar a adoção e o uso de APIs específicas em grande escala. O presente estudo adotará uma abordagem de mineração similar para identificar a adoção de VTs, por exemplo, ocorrências de \textit{Thread.ofVirtual()} e \textit{executors} de VT como instâncias criadas por \textit{Executors.newVirtualThreadPerTaskExecutor()}) em projetos \textit{open-source} Java.